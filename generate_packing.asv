% parameters
num_polygons = 6;
sigma = 3;
sides = 3;
particles_per_side = 1;
total_particles = sides * particles_per_side;
m = ones(1, total_particles);
k_int = 10000;
b_trans = 2;
b_ang = 2;

dt = 0.001;
max_t = 100;


% BINARY SEARCH PARAMS
L = 5;
r_scale = 0.99;
P_t = 10;
P_l = 0.995 * P_t;
P_h = 1.005 * P_t;
L_l = -1;
L_h = -1;
L_tol = 0.00000000001;


polygons = cell(1, num_polygons);

% generate initial conditions without overlap
pressure = 1;
while pressure > 0
    for i = 1:num_polygons
        q = [rand()*(xmax-xmin)+xmin, rand()*(ymax-ymin)+ymin];
        v = rand(1, 2)*5 - 2.5;
        w = 0;
        polygons{i} = regular_polygon(sigma, sides, m, q, v, w, particles_per_side);
    end
    box = periodic_box_polygon(polygons, k_int, b_trans, b_ang, -L/2, L/2, -L/2, L/2);
    pressure = box.iterate_time(dt); % calculate initial pressure, is it
    % ok to just do this? I think you're adding a time step in the final
    % run.
end

disp('Found Starting Config')

old_state = box;

while true
    [t_values, q_series, v_series, theta_series, w_series,...
    pressure_series, vertices_series, box, polygons, particles_per_side,...
    xmin_series, xmax_series, ymin_series, ymax_series] =...
    energy_minimize(system, L, E_thresh, dt, max_t);

    % DECIDE WHETHER OR NOT TO DISPLAY MINIMIZATION PROCESS

    L_prior = L;
    P = pressure_series(end)
end

function [t_values, q_series, v_series, theta_series, w_series,...
    pressure_series, vertices_series, box, polygons, particles_per_side,...
    xmin_series, xmax_series, ymin_series, ymax_series] =...
    energy_minimize(system, L, E_thresh, dt, max_t)
    
    box = copy(system);
    num_polygons = size(box.polygons, 2);

    max_t = round(max_t / dt) * dt;
    t_values = 0:dt:max_t;
    num_steps = length(t_values);
    q_series = cell(1, num_polygons);
    v_series = cell(1, num_polygons);
    theta_series = cell(1, num_polygons);
    w_series = cell(1, num_polygons);
    pressure_series = zeros(1, num_steps);
    vertices_series = cell(num_polygons, num_steps);
    xmin_series = ones(1, num_steps) * (-L/2);
    xmax_series = ones(1, num_steps) * (L/2);
    ymin_series = ones(1, num_steps) * (-L/2);
    ymax_series = ones(1, num_steps) * (L/2);
    E_series = zeros(num_steps, 3);
    
    for step = 1:num_steps
        pressure_series(step) = box.iterate_time(dt);
    
        xmin_series(step) = box.xmin;
        xmax_series(step) = box.xmax;
        ymin_series(step) = box.ymin;
        ymax_series(step) = box.ymax;
    
        [E_series(step,1),E_series(step,2),E_series(step,3)] = box.get_energy();
        for polygon = 1:num_polygons
            [poly] = deal(box.polygons(polygon));
            q_series{polygon}(step, :) = box.apply_pbc2d(poly.q);
            v_series{polygon}(step, :) = poly.v;
            theta_series{polygon}(step) = poly.theta;
            w_series{polygon}(step) = poly.w;
            vertices_series{polygon, step} = poly.vertices_relative + q_series{polygon}(step, :);
        end

        if E_series(step,3) <= E_thresh
            polygons = box.polygons;
            particles_per_side = polygons(1).particles_per_side;
            break
        end
    end
    disp('No Convergence')
end